---
title: "Quantum Field Theory in R"
author: "John Akwei, Senior Data Scientist"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
    code_folding: show
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.align = 'center', cache = FALSE)  # Changed to FALSE
```


## Abstract

This document presents a mathematical proof of key concepts in Quantum Field Theory (QFT), demonstrating how quantum fields emerge from the marriage of quantum mechanics and special relativity. We provide both theoretical derivations and computational implementations in R to illustrate the mathematical structure underlying particle physics.

<br />
<br />

## 1. Foundation: The Klein-Gordon Equation

### 1.1 Theoretical Derivation

Starting with the relativistic energy-momentum relation:
```
E² = (pc)² + (mc²)²
```

In quantum mechanics, we make the substitutions:
- E → iℏ ∂/∂t
- p → -iℏ ∇

This gives us the Klein-Gordon equation for a scalar field φ(x,t):
```
(□ + m²c²/ℏ²)φ(x,t) = 0
```

where □ = ∂²/∂t² - c²∇² is the d'Alembert operator.

### 1.2 R Implementation

```{r libraries}
# Load required libraries
library(ggplot2)
library(plotly)
library(viridis)
library(reshape2)
library(gridExtra)
```

```{r klein-gordon}
# Klein-Gordon equation solver
klein_gordon_solver <- function(x, t, m, hbar = 1, c = 1) {
  # Plane wave solution: φ(x,t) = A * exp(i(kx - ωt))
  # Dispersion relation: ω² = c²k² + (mc²/ℏ)²
  
  k <- seq(-5, 5, length.out = 100)
  omega <- sqrt(c^2 * k^2 + (m * c^2 / hbar)^2)
  
  # Generate field values
  phi <- matrix(0, nrow = length(x), ncol = length(t))
  
  for (i in seq_along(x)) {
    for (j in seq_along(t)) {
      # Sum over momentum modes (simplified)
      phi[i, j] <- sum(exp(1i * (k * x[i] - omega * t[j])))
    }
  }
  
  return(Re(phi))
}

# Generate field data
x <- seq(-10, 10, length.out = 50)
t <- seq(0, 5, length.out = 20)
m <- 1.0

field <- klein_gordon_solver(x, t, m)

# Visualization
field_df <- expand.grid(x = x, t = t)
field_df$phi <- as.vector(field)

ggplot(field_df, aes(x = x, y = t, fill = phi)) +
  geom_tile() +
  scale_fill_viridis_c(name = "φ(x,t)") +
  labs(title = "Klein-Gordon Field Evolution",
       x = "Position (x)", y = "Time (t)") +
  theme_minimal()
```

<br />
<br />

## 2. Quantization: From Fields to Particles

### 2.1 Canonical Quantization

The classical field φ(x,t) and its conjugate momentum π(x,t) = ∂φ/∂t are promoted to operators satisfying canonical commutation relations:

```
[φ̂(x,t), π̂(y,t)] = iℏδ³(x-y)
[φ̂(x,t), φ̂(y,t)] = 0
[π̂(x,t), π̂(y,t)] = 0
```

### 2.2 Mode Expansion

The quantum field can be expanded in terms of creation and annihilation operators:

```
φ̂(x,t) = ∫ d³k/(2π)³ * 1/√(2ωₖ) * [aₖe^(i(k·x-ωₖt)) + bₖ†e^(-i(k·x-ωₖt))]
```

where ωₖ = √(c²k² + (mc²/ℏ)²)

### 2.3 R Implementation of Quantization

```{r quantum-field}
# Quantum field mode expansion
quantum_field_modes <- function(x, t, n_modes = 50) {
  # Create momentum grid
  k_max <- 5
  k <- seq(-k_max, k_max, length.out = n_modes)
  
  # Dispersion relation
  m <- 1.0
  omega_k <- sqrt(k^2 + m^2)  # Setting c = ℏ = 1
  
  # Random complex amplitudes (representing quantum fluctuations)
  set.seed(42)
  a_k <- complex(real = rnorm(n_modes), imaginary = rnorm(n_modes))
  b_k <- complex(real = rnorm(n_modes), imaginary = rnorm(n_modes))
  
  # Field calculation
  phi <- array(0, dim = c(length(x), length(t)))
  
  for (i in seq_along(x)) {
    for (j in seq_along(t)) {
      # Positive frequency modes
      positive_modes <- a_k * exp(1i * (k * x[i] - omega_k * t[j]))
      # Negative frequency modes  
      negative_modes <- Conj(b_k) * exp(-1i * (k * x[i] - omega_k * t[j]))
      
      # Properly normalize each mode and sum
      normalized_modes <- (positive_modes + negative_modes) / sqrt(2 * omega_k)
      phi[i, j] <- sum(normalized_modes)
    }
  }
  
  return(Re(phi))
}

# Generate quantum field
x_grid <- seq(-5, 5, length.out = 100)
t_grid <- seq(0, 2, length.out = 50)
quantum_phi <- quantum_field_modes(x_grid, t_grid)

# Visualization
quantum_df <- expand.grid(x = x_grid, t = t_grid)
quantum_df$phi <- as.vector(quantum_phi)

p1 <- ggplot(quantum_df, aes(x = x, y = t, fill = phi)) +
  geom_tile() +
  scale_fill_viridis_c(name = "φ(x,t)") +
  labs(title = "Quantum Field Fluctuations",
       x = "Position (x)", y = "Time (t)") +
  theme_minimal()

print(p1)

# Show field at specific time
t_slice <- quantum_phi[, 25]  # Middle time slice
ggplot(data.frame(x = x_grid, phi = t_slice), aes(x = x, y = phi)) +
  geom_line(color = "blue", size = 1) +
  labs(title = "Quantum Field at t = 1.0",
       x = "Position (x)", y = "Field Value φ(x)") +
  theme_minimal()
```

<br />
<br />

## 3. The Dirac Equation for Fermions

### 3.1 Theoretical Foundation

For spin-1/2 particles, the Dirac equation provides the relativistic description:

```
(iγᵘ∂ᵤ - mc/ℏ)ψ = 0
```

where γᵘ are the Dirac gamma matrices satisfying {γᵘ, γᵛ} = 2ηᵘᵛ.

### 3.2 Spin-Statistics Connection

The document mentions that fermions (half-integer spin) obey the Pauli exclusion principle due to their antisymmetric wavefunctions. This is implemented through anticommutation relations:

```
{ψ̂ᵢ(x,t), ψ̂ⱼ†(y,t)} = δⁱʲδ³(x-y)
```

### 3.3 R Implementation of Dirac Spinors

```{r dirac-spinors}
# Dirac spinor solutions
dirac_spinor_solutions <- function(p, m = 1, spin_up = TRUE) {
  # Energy from relativistic dispersion
  E <- sqrt(p^2 + m^2)
  
  # Create 4-component spinor
  if (spin_up) {
    # Positive energy, spin up
    u_spinor <- c(1, 0, p/(E + m), 0)
  } else {
    # Positive energy, spin down  
    u_spinor <- c(0, 1, 0, p/(E + m))
  }
  
  # Normalize
  u_spinor <- u_spinor / sqrt(sum(abs(u_spinor)^2))
  
  return(list(
    spinor = u_spinor,
    energy = E,
    momentum = p
  ))
}

# Generate spinor solutions for different momenta
momenta <- seq(-2, 2, by = 0.5)
spinor_data <- data.frame()

for (p in momenta) {
  spin_up <- dirac_spinor_solutions(p, spin_up = TRUE)
  spin_down <- dirac_spinor_solutions(p, spin_up = FALSE)
  
  spinor_data <- rbind(spinor_data, 
                      data.frame(momentum = p, 
                                energy = spin_up$energy,
                                spin = "up"),
                      data.frame(momentum = p, 
                                energy = spin_down$energy,
                                spin = "down"))
}

# Plot dispersion relation
ggplot(spinor_data, aes(x = momentum, y = energy, color = spin)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = "Dirac Particle Dispersion Relation",
       x = "Momentum (p)", y = "Energy (E)",
       color = "Spin State") +
  theme_minimal() +
  scale_color_manual(values = c("up" = "red", "down" = "blue"))

# Display some spinor components
cat("Example Dirac Spinors:\n")
for (i in c(1, 3, 5)) {
  p <- momenta[i]
  sol <- dirac_spinor_solutions(p)
  cat(sprintf("p = %.1f: u = (%.3f, %.3f, %.3f, %.3f)\n", 
              p, sol$spinor[1], sol$spinor[2], sol$spinor[3], sol$spinor[4]))
}
```

<br />
<br />

## 4. Virtual Particles and Quantum Fluctuations

### 4.1 Theoretical Background

As mentioned in the document, virtual particles are temporary excitations of quantum fields due to the energy-time uncertainty principle:

```
ΔE × Δt ≥ ℏ/2
```

This allows for temporary violations of energy conservation, leading to particle-antiparticle pairs.

### 4.2 Vacuum Fluctuations

The quantum vacuum is not empty but filled with zero-point energy:

```
⟨0|Ĥ|0⟩ = ∑ₖ (ℏωₖ/2)
```

### 4.3 R Implementation of Vacuum Fluctuations

```{r vacuum-fluctuations}
# Vacuum fluctuation simulation
vacuum_fluctuations <- function(x, t, n_modes = 100) {
  # Zero-point fluctuations
  k <- seq(0.1, 5, length.out = n_modes)
  omega_k <- sqrt(k^2 + 1)  # m = 1
  
  # Zero-point energy contribution
  zero_point <- sum(0.5 * omega_k)
  
  # Quantum fluctuations (Gaussian random field)
  set.seed(123)
  fluctuation_field <- matrix(0, nrow = length(x), ncol = length(t))
  
  for (i in seq_along(k)) {
    # Random phase and amplitude
    phase <- runif(1, 0, 2*pi)
    amplitude <- rnorm(1, sd = 1/sqrt(2*omega_k[i]))
    
    for (j in seq_along(x)) {
      for (l in seq_along(t)) {
        fluctuation_field[j, l] <- fluctuation_field[j, l] + 
          amplitude * cos(k[i] * x[j] - omega_k[i] * t[l] + phase)
      }
    }
  }
  
  return(list(
    field = fluctuation_field,
    zero_point_energy = zero_point
  ))
}

# Generate vacuum fluctuations
x_vac <- seq(-3, 3, length.out = 60)
t_vac <- seq(0, 1, length.out = 30)
vacuum_state <- vacuum_fluctuations(x_vac, t_vac)

# Visualize vacuum fluctuations
vac_df <- expand.grid(x = x_vac, t = t_vac)
vac_df$phi <- as.vector(vacuum_state$field)

ggplot(vac_df, aes(x = x, y = t, fill = phi)) +
  geom_tile() +
  scale_fill_viridis_c(name = "Fluctuation\nAmplitude") +
  labs(title = paste("Quantum Vacuum Fluctuations\n(Zero-point energy =", 
                    round(vacuum_state$zero_point_energy, 2), ")"),
       x = "Position (x)", y = "Time (t)") +
  theme_minimal()

# Statistical properties
cat("Vacuum Fluctuation Statistics:\n")
cat("Mean field value:", mean(vacuum_state$field), "\n")
cat("RMS fluctuation:", sqrt(mean(vacuum_state$field^2)), "\n")
cat("Zero-point energy:", vacuum_state$zero_point_energy, "\n")
```

<br />
<br />

## 5. Electromagnetic Field Quantization

### 5.1 Photon Field

The electromagnetic field is quantized by expanding in terms of photon creation/annihilation operators:

```
Â(x,t) = ∑ₖ,λ √(ℏωₖ/2ε₀V) * [aₖλe^(i(k·x-ωₖt))εₖλ + h.c.]
```

where λ labels polarization states and εₖλ are polarization vectors.

### 5.2 R Implementation of Photon Field

```{r photon-field}
# Electromagnetic field quantization
photon_field <- function(x, y, z, t, polarization = "linear") {
  # Photon momentum modes
  k_vals <- seq(0.5, 3, by = 0.5)
  
  # Initialize field components
  E_field <- array(0, dim = c(length(x), length(y), length(z), 3))
  
  for (k in k_vals) {
    omega <- k  # Photon: ω = ck, c = 1
    
    # Polarization vectors
    if (polarization == "linear") {
      epsilon_1 <- c(1, 0, 0)  # x-polarization
      epsilon_2 <- c(0, 1, 0)  # y-polarization
    } else {
      epsilon_1 <- c(1, 1i, 0)/sqrt(2)  # circular polarization
      epsilon_2 <- c(1, -1i, 0)/sqrt(2)
    }
    
    # Random amplitudes
    a1 <- complex(real = rnorm(1), imaginary = rnorm(1))
    a2 <- complex(real = rnorm(1), imaginary = rnorm(1))
    
    # Field calculation
    for (i in seq_along(x)) {
      for (j in seq_along(y)) {
        for (l in seq_along(z)) {
          # Plane wave propagation in z-direction
          phase <- k * z[l] - omega * t
          wave_factor <- exp(1i * phase)
          
          # Add both polarization modes
          field_contrib <- Re(a1 * epsilon_1 * wave_factor + 
                             a2 * epsilon_2 * wave_factor)
          
          E_field[i, j, l, ] <- E_field[i, j, l, ] + field_contrib
        }
      }
    }
  }
  
  return(E_field)
}

# Generate electromagnetic field
x_em <- seq(-1, 1, length.out = 20)
y_em <- seq(-1, 1, length.out = 20)  
z_em <- seq(0, 5, length.out = 50)
t_em <- 0

em_field <- photon_field(x_em, y_em, z_em, t_em)

# Visualize E-field magnitude along z-axis
E_magnitude <- sqrt(em_field[10, 10, , 1]^2 + em_field[10, 10, , 2]^2 + em_field[10, 10, , 3]^2)

ggplot(data.frame(z = z_em, E_mag = E_magnitude), aes(x = z, y = E_mag)) +
  geom_line(color = "red", size = 1.2) +
  labs(title = "Electromagnetic Field Magnitude vs. Position",
       x = "Position z", y = "|E|") +
  theme_minimal()

# Show field components
E_components <- data.frame(
  z = rep(z_em, 3),
  E_value = c(em_field[10, 10, , 1], em_field[10, 10, , 2], em_field[10, 10, , 3]),
  component = rep(c("Ex", "Ey", "Ez"), each = length(z_em))
)

ggplot(E_components, aes(x = z, y = E_value, color = component)) +
  geom_line(size = 1) +
  labs(title = "Electromagnetic Field Components",
       x = "Position z", y = "Field Amplitude",
       color = "Component") +
  theme_minimal()
```

<br />
<br />

## 6. Spin-Statistics Theorem Verification

### 6.1 Mathematical Proof Outline

The spin-statistics theorem states that:
- Integer spin particles (bosons) have symmetric wavefunctions
- Half-integer spin particles (fermions) have antisymmetric wavefunctions

This follows from the requirement of Lorentz invariance and causality in relativistic quantum field theory.

### 6.2 R Verification

```{r spin-statistics}
# Spin-statistics verification
verify_spin_statistics <- function(n_particles = 2, spin = 0.5) {
  # Create multi-particle wavefunction
  if (spin %% 1 == 0) {
    # Boson: symmetric wavefunction
    cat("Boson (spin =", spin, "):\n")
    cat("Exchange symmetry: ψ(x₁,x₂) = +ψ(x₂,x₁)\n")
    
    # Numerical example with Gaussian wavefunctions
    x1 <- 1; x2 <- 2
    psi_original <- exp(-(x1^2 + x2^2)/2)
    psi_exchanged <- exp(-(x2^2 + x1^2)/2)
    
    cat("Original: ψ(1,2) =", psi_original, "\n")
    cat("Exchanged: ψ(2,1) =", psi_exchanged, "\n")
    cat("Ratio:", psi_exchanged/psi_original, "\n\n")
    
    return(data.frame(
      particle_type = "Boson",
      spin = spin,
      symmetry = "Symmetric",
      ratio = psi_exchanged/psi_original
    ))
    
  } else {
    # Fermion: antisymmetric wavefunction  
    cat("Fermion (spin =", spin, "):\n")
    cat("Exchange antisymmetry: ψ(x₁,x₂) = -ψ(x₂,x₁)\n")
    
    # Antisymmetric combination
    x1 <- 1; x2 <- 2
    psi_original <- (exp(-(x1^2)/2) * exp(-(x2^2)/2) - 
                    exp(-(x2^2)/2) * exp(-(x1^2)/2))/sqrt(2)
    
    # After exchange
    psi_exchanged <- (exp(-(x2^2)/2) * exp(-(x1^2)/2) - 
                     exp(-(x1^2)/2) * exp(-(x2^2)/2))/sqrt(2)
    
    cat("Original: ψ(1,2) =", psi_original, "\n")
    cat("Exchanged: ψ(2,1) =", psi_exchanged, "\n")
    cat("Ratio:", psi_exchanged/psi_original, "\n\n")
    
    return(data.frame(
      particle_type = "Fermion",
      spin = spin,
      symmetry = "Antisymmetric",
      ratio = psi_exchanged/psi_original
    ))
  }
}

# Test both cases
results_boson <- verify_spin_statistics(spin = 1)    # Boson
results_fermion <- verify_spin_statistics(spin = 0.5)  # Fermion

# Combine results
all_results <- rbind(results_boson, results_fermion)

# Visualize the spin-statistics relationship
spin_values <- c(0, 0.5, 1, 1.5, 2)
particle_types <- ifelse(spin_values %% 1 == 0, "Boson", "Fermion")
symmetries <- ifelse(spin_values %% 1 == 0, "Symmetric", "Antisymmetric")

spin_stats_df <- data.frame(
  spin = spin_values,
  type = particle_types,
  symmetry = symmetries
)

ggplot(spin_stats_df, aes(x = spin, y = type, color = symmetry)) +
  geom_point(size = 4) +
  scale_x_continuous(breaks = spin_values) +
  labs(title = "Spin-Statistics Theorem Verification",
       x = "Particle Spin", y = "Particle Type",
       color = "Wavefunction\nSymmetry") +
  theme_minimal() +
  theme(axis.text = element_text(size = 12))

# si_exchanged <- (exp(-(x2^2)/2) * exp(-(x1^2)/2) - 
#                      exp(-(x1^2)/2) * exp(-(x2^2)/2))/sqrt(2)
#     
#     cat("Original: ψ(1,2) =", psi_original, "\n")
#     cat("Exchanged: ψ(2,1) =", psi_exchanged, "\n")
#     cat("Ratio:", psi_exchanged/psi_original, "\n\n")

# Test both cases
verify_spin_statistics(spin = 1)    # Boson
verify_spin_statistics(spin = 0.5)  # Fermion
```

<br />
<br />

## 7. Conclusion: The Unity of QFT

This proof demonstrates several key aspects of Quantum Field Theory:

1. **Field Quantization**: Classical fields become quantum operators with particle interpretations
2. **Relativistic Invariance**: The Klein-Gordon and Dirac equations ensure proper relativistic behavior
3. **Spin-Statistics Connection**: The mathematical structure necessarily links spin with exchange statistics
4. **Virtual Particles**: Quantum fluctuations are real consequences of the uncertainty principle
5. **Unified Framework**: All fundamental forces and particles emerge from quantum field excitations

The R implementations provide computational verification of these theoretical principles, showing how abstract mathematical concepts translate into observable physical phenomena.

### Key Insights from the Analysis

- Quantum fields are the fundamental entities, not particles
- Particle-antiparticle creation/annihilation is a natural consequence of field quantization
- Spin determines whether particles can occupy the same quantum state
- Virtual particles contribute measurably to physical processes
- The mathematical structure of QFT is both elegant and experimentally verified

This mathematical framework successfully describes all known fundamental interactions except gravity, representing one of physics' greatest theoretical achievements.